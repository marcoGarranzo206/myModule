#scrip to preprocess trees from parsestrings as generated by stanford corenlp
#each tree node label has, besides its label from stanford (if any, or can 
#be erased) the following features:
# label/Fsc/Fd1/Fd2
#label: what interaction is in the sentence
# for unlabaled instances doesnt matter, onlt
#for trainin purposes
#Fsc: Is a target drug in any descendant of the tree
#Fd1 and Fd2: distance from the node to the drug1 and 2
#Initally, leaves distance is the linear distance between the
#word and the drug
#if not a leave, the value with the least abs value of its children
import warnings
from nltk.tree import ParentedTree


#we are goin to append our label 
#to the labels and then compare if 
#we did it right

class treeProcessor:

    def __init__(self,stringTree,w1,w2,label):

        self.label = label
        self.ptree = ParentedTree.fromstring(stringTree)   
        leaf_values = self.ptree.leaves()

        e1 = -1
        e2 = -1
        for (i,token) in enumerate(leaf_values):

            if w1 == token:

                e1 = i

            elif w2 == token:

                e2 = i

            if e2 != -1 and e1 != -1:

                break
        
        if e1 == -1 or e2 == -1:

            raise ValueError(f"{w1} or {w2} not found in sentence {leaf_values}")
        self.idx_to_pos = dict()
        for i in range(len(leaf_values)):

            self.idx_to_pos[tuple(list(self.ptree.leaf_treeposition(i))[:-1])] = ( pos_diff(i - e1) + 9, pos_diff(i - e2)+9)

        self.w1_index = list(self.ptree.leaf_treeposition(e1))[:-1]
        self.w2_index = list(self.ptree.leaf_treeposition(e2))[:-1]
    
    def processTree(self):

        self._addContext()
        self._addDistance(self.ptree)
        self._addLabel()
        return self.ptree

    def _addLabel(self):

        n = 0
        for node in DFS(self.ptree):

            n += 1
            node._label = self.label + "/" + node._label

    def _addContext(self):

        for x in getAncestors(self.ptree[self.w1_index]):
            x._label = "0/"

        for x in getAncestors(self.ptree[self.w2_index]):
            
            if not x._label.endswith("/"):

                x._label = "0/"

        addOnes(self.ptree)

    def _addDistance(self,ptree):

        #TODO: check number of calls being made. Should there be a set of visited children?
        if not type(ptree) is str:

            pos = ptree.treeposition()
            if pos in self.idx_to_pos:

                pos1,pos2 = self.idx_to_pos[pos]
                ptree._label = ptree._label + str(pos1) + "/" + str(pos2)
                return (pos1,pos2)

            else:

                pos1_pos2 = [self._addDistance(child) for child in ptree]
                pos1 = min( [x[0] for x in pos1_pos2] , key = lambda x: abs(x-9))
                pos2 = min( [x[1] for x in pos1_pos2] , key = lambda x: abs(x-9))
                ptree._label = ptree._label  + str(pos1) + "/" + str(pos2)
                return (pos1,pos2)
        
        return 100

def pos_diff(x):

    if abs(x) <= 5:

        return x
    elif abs(x) <= 10:

        return 6*(-1 if x <0 else 1)
    elif abs(x) <= 15:

        return 7*(-1 if x <0 else 1)

    elif abs(x) <= 20:

        return 8*(-1 if x <0 else 1)
    return 9*(-1 if x < 0 else 1)


def getAncestors(tree):

    if tree:

        yield tree
        yield  from getAncestors(tree.parent())

def DFS(tree):

    visited = set()
    def _DFS(tree):

        if not type(tree) is str:

            yield tree
            for node in tree:

                if id(node) not in visited:

                    visited.add(id(node))
                    yield from _DFS(node)
    
    return _DFS(tree)

def addOnes(tree):


    if not type(tree) is str:

        if not tree._label.endswith("/"):

            tree._label = "1/"
        
        [addOnes(child) for child in tree]

def from_file(file):

    with open(file, "r") as f:

        for i,line in enumerate(f):

            line = line[:-1].lower()
            fields = line.split("\t")
            relation = fields[0]
            w1 = fields[1]
            name1 = fields[2]
            nname1 = fields[3]
            w2 = fields[4]
            name2 = fields[5]
            nname2 = fields[6]
            treeString = fields[7]
            
            try:

                processor = treeProcessor(treeString,w1,w2,relation)
                processor.processTree()
                yield {w1:(name1,nname1),w2:(name2,nname2)}, processor

            except Exception as e:

                print(f"Error found on line {i + 1} of {file}, skipping line")
                print(line)
                warnings.warn(f"Exception raised: {e}")

if __name__ == "__main__":

    import sys
    tree_file = sys.argv[1]
    output_file = sys.argv[2]

    with open(output_file,"w+") as j:
        for processed in from_file(tree_file):

            j.write(" ".join(str(processed.ptree).split()))
            j.write("\n")
